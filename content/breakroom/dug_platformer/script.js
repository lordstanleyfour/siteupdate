window.addEventListener('load', function () {
    const loading = document.getElementById('loading');
    loading.style.display = 'none';
    //'load' event listener will run codeblock once all elements are loaded and available. The above code will hide the loading text with element id 'loading' once all elements are loaded. This is a quick and dirty loading screen.//
    const canvas = document.getElementById('canvas1');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particlesArray = [];
    const particlesArray2 = [];
    const particlesArray3 = [];
    

    //declare statics here for now; x, y, width, height, player, image, sw, sh, duplicates
    //x, y, width, height, player, image, sw, sh, type, canvasHeight
    
    const caveEntrance = document.getElementById("caveEntrance");

    // full game height on home PC 969
    
    class State {
        constructor(state){
            this.state = state;
        }
    }

    class InputHandler {
        constructor() {
            this.lastKey = ' '; // empty string to store the e.key info
            window.addEventListener('keydown', (e) => {
                //callback function on event listener in js has an autogenerated event object which is automatically passed as an argument in the event listener function, doesn't matter what you label it (we've called it 'e'.) It has a property called 'key' which stores information about keypresses.
                //Arrow functions do not bind their own 'this' but inherit it from their parent scope; lexical scoping. Lets us retain the scope of the caller inside the function so the 'bind' keyword doesn't need to be used.
                
                //console.log(e.key);
                switch(e.key){
                    case 'ArrowLeft':
                        this.lastKey = 'PRESS left';
                        // if ArrowLeft pressed then the above string gets sent to lastKey
                        break;
                    case 'ArrowRight':
                        this.lastKey = 'PRESS right';
                        break;
                    case 'ArrowDown':
                        this.lastKey = 'PRESS down';
                        break;
                    case 'ArrowUp':
                        this.lastKey = 'PRESS up';
                        break;
                    case ' ':
                    this.lastKey = 'PRESS space';
                    break;
                }
            });
            window.addEventListener('keyup', (e) => {
                switch(e.key){
                    case 'ArrowLeft':
                        this.lastKey = 'RELEASE left';
                        break;
                    case 'ArrowRight':
                        this.lastKey = 'RELEASE right';
                        break;
                    case 'ArrowDown':
                        this.lastKey = 'RELEASE down';
                        break;
                    case 'ArrowUp':
                        this.lastKey = 'RELEASE up';
                        break;
                    case ' ':
                        this.lastKey = 'RELEASE space';
                        break;
                }
            });
        }
    }

    class Player {
        constructor (gameWidth, gameHeight){
            this.gameWidth = gameWidth;
            this.gameHeight = gameHeight;
            this.states = [new StandingLeft(this), new StandingRight(this), new SittingLeft(this), new SittingRight(this), new RunningLeft(this), new RunningRight(this), new JumpingLeft(this), new JumpingRight(this), new FallingLeft(this), new FallingRight(this), new RollingLeft(this), new RollingRight(this)]; // ensure that these are added in the correct order as written in the enum in state.js
            this.currentState = this.states[1];
            this.image = document.getElementById("dogImage");
            this.width = 200;
            this.height = 2182/12;
            this.x = this.gameWidth/2 - this.width/2;
            this.y = this.gameHeight - this.height;
            //sprite animation
            this.frameX = 0;
            this.frameY = 0;
            this.maxFrame = 6;
            //movement
            this.speed = 0;
            this.maxSpeed = 10;
            this.jumpSpeed = 12;
            this.vy = 0;
            this.weight = 0.5; //gravity force down
            this.offset = 0; //this.x is player position relative to the window. this is relative to the rest of the drawn objects on canvas
            this.offsetPadding = 350; // to leave space when running left/right to see what's coming
            this.offsetY = 0;
            this.offsetYPadding = 100;
            //animation timer
            this.fps = 30;
            this.frameTimer = 0;
            this.frameInterval = 1000/this.fps
            this.frameCounter = 0;
            this.countFrames = true;
            this.score = 0;
            //switches
            this.collideSwitchBottom = false;
            this.collideSwitchTop = false;
            this.collideSwitchLeft = false; // doesn't seem to be needed yet
            this.collideSwitchRight = false; // doesn't seem to be needed yet
            this.alive = true;
            //counters
            this.tokensCollected = 0;
            this.jumpBoostCollected = false;
            this.speedBoostCollected = false;
            this.speedBoostCounter = 0;
            this.speedBoostCap = 0;
        }
        draw(context, deltaTime){
            if (this.frameTimer > this.frameInterval){
                if (this.frameX < this.maxFrame) {
                    this.frameX ++;
                    if (this.countFrames) this.frameCounter ++;
                } else {
                    this.frameX = 0;
                    if (this.countFrames) this.frameCounter ++;
                }
                this.frameTimer = 0;
            } else {
                this.frameTimer += deltaTime;
            }
    
            if (this.alive) this.image = document.getElementById("dogImage");
            else {
                this.frameX = 0;
                this.frameY = 0;
                this.maxFrame = 0;
                this.image = document.getElementById("dead");
            }
            context.drawImage(this.image, this.width * this.frameX, this.height * this.frameY, this.width, this.height, this.x + this.offset, this.y, this.width, this.height);
    
            /* if (this.alive) context.drawImage(this.image, this.width * this.frameX, this.height * this.frameY, this.width, this.height, this.x + this.offset, this.y, this.width, this.height);
            else {
                this.image = document.getElementById('dead');
                context.drawImage(this.image, this.width * this.frameX, this.height * this.frameY, this.width, this.height, this.x + this.offset, this.y, this.width, this.height); */
                /* context.beginPath();
                context.fillStyle = 'red';
                context.fillRect(this.x + this.offset, this.y, this.width, this.height);
                context.fillStyle = 'black';
                context.font = '35px Impact'
                context.textAlign = 'center'
                context.fillText('CENSORED', this.x + this.width/2 + this.offset, this.y + this.height/2)
                context.closePath(); */
          /*   } */
        }
        update(input){
            if (this.alive){
                //speedBoostCap logic???????????????????????????????????????????????????????????????
                if (this.speedBoostCollected && this.speedBoostCap == 0) {
                    this.maxSpeed = 15;
                    this.jumpSpeed = 20;
                } else if ((!this.speedBoostCollected || this.speedBoostCap <= this.speedBoostCounter) && (this.tokensCollected > 0 || this.jumpBoostCollected)){
                    this.maxSpeed = 10;
                    this.jumpSpeed = 16;
                } else if ((!this.speedBoostCollected || this.speedBoostCap <= this.speedBoostCounter) && this.tokensCollected == 0){
                    this.maxSpeed = 10;
                    this.jumpSpeed = 12;
                }
                this.currentState.handleInput(input);
                //horizontal movement
                this.x += this.speed;
                //horizontal canvas offset
                //going left
                if (this.x <= 0 + this.offsetPadding && (this.currentState == this.states[4] || this.currentState == this.states[6] || this.currentState == this.states[8] || this.currentState == this.states[10] || this.currentState == this.states[11])) {
                    this.x = 0 + this.offsetPadding;
                    this.offset += this.speed;
                } 
                //going right
                else if (this.x >= this.gameWidth - this.width - this.offsetPadding && (this.currentState == this.states[5] || this.currentState == this.states[7] || this.currentState == this.states[9] || this.currentState == this.states[10] || this.currentState == this.states[11])) {
                    this.x = this.gameWidth - this.width - this.offsetPadding;
                    this.offset += this.speed;
                }
                //lock left side
                if (this.offset < -500){
                    this.offset = -500;
                }
                //lock right side
                if (this.offset > 9500 - this.gameWidth){
                    this.offset = 9500 - this.gameWidth;
                }
    
                // vertical movement
                this.y += this.vy;
                if (!this.onGround()){
                    this.vy += this.weight;
                }
    
                //death from falling
                if(this.vy > 25 && this.onGround()) this.alive = false;
    
                //cancel vertical speed on landing
                if (this.onGround() || this.collideSwitchBottom) {
                    this.vy = 0;
                }
                //vertical canvas offset
                //going up            
                if (this.y - this.offsetYPadding + this.offsetY <= 0 && this.vy < 0) {
                    this.offsetY += this.vy;
                    this.offsetY = Math.floor(this.offsetY);
                }
    
                //going down
                else if (this.y + this.height + this.offsetYPadding > this.gameHeight - this.offsetYPadding + this.offsetY && this.vy > 0 ) {
                    this.offsetY += this.vy;
                    if (this.offsetY > 0) this.offsetY = 0;
                }
    
                //lock top            
                if (this.offsetY < -(1000 - this.gameHeight)) this.offsetY = -(1000 - this.gameHeight); 
                
                //prevent falling through floor
                if (this.y > this.gameHeight - this.height) this.y = this.gameHeight - this.height;
                
                //detect if falling after running
                if (this.currentState == this.states[4] && this.vy > 1) this.currentState = this.states[8]
                if (this.currentState == this.states[5] && this.vy > 1) this.currentState = this.states[9]
            }
        }
        setState(state){
            this.currentState = this.states[state];
            this.currentState.enter();
        }
        onGround(){
            return this.y >= this.gameHeight - this.height;
        }
        collision(){
            if (this.collideSwitchBottom) this.vy = 0;
        }
    }

    class StandingLeft extends State {
        constructor(player){
            super('STANDING LEFT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 1;
            this.player.speed = 0;
        }
        handleInput(input){
            if (input === 'RELEASE right') this.player.setState(states.STANDING_RIGHT);
            else if (input === 'PRESS down') this.player.setState(states.SITTING_LEFT);
            else if (input === 'PRESS right') this.player.setState(states.RUNNING_RIGHT);
            else if (input === 'PRESS left') this.player.setState(states.RUNNING_LEFT);
            else if (input === 'PRESS up') this.player.setState(states.JUMPING_LEFT);
            else if (input === 'PRESS space') this.player.setState(states.ROLLING_LEFT);
        }
    }

    class StandingRight extends State {
        constructor(player){
            super('STANDING RIGHT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 0;
            this.player.speed = 0;
        }
        handleInput(input){
            if (input === 'RELEASE left') this.player.setState(states.STANDING_LEFT);
            else if (input === 'PRESS down') this.player.setState(states.SITTING_RIGHT);
            else if (input === 'PRESS right') this.player.setState(states.RUNNING_RIGHT);
            else if (input === 'PRESS left') this.player.setState(states.RUNNING_LEFT);
            else if (input === 'PRESS up') this.player.setState(states.JUMPING_RIGHT);
            else if (input === 'PRESS space') this.player.setState(states.ROLLING_RIGHT);
        }
    }

    class SittingLeft extends State {
        constructor(player){
            super('SITTING LEFT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 4;
            this.player.frameY = 9;
            this.player.speed = 0;
        }
        handleInput(input){
            if (input === 'PRESS right') this.player.setState(states.SITTING_RIGHT);
            else if (input === 'RELEASE down') this.player.setState(states.STANDING_LEFT);
        }
    }

    class SittingRight extends State {
        constructor(player){
            super('SITTING RIGHT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 4;
            this.player.frameY = 8;
            this.player.speed = 0;
        }
        handleInput(input){
            if (input === 'PRESS left') this.player.setState(states.SITTING_LEFT);
            else if (input === 'RELEASE down') this.player.setState(states.STANDING_RIGHT);
    
        }
    }

    class RunningLeft extends State {
        constructor(player){
            super('RUNNING LEFT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 8;
            this.player.frameY = 7;
            this.player.speed = -this.player.maxSpeed;
        }
        handleInput(input){
            if (input === 'PRESS right') this.player.setState(states.RUNNING_RIGHT);
            else if (input === 'RELEASE left') this.player.setState(states.STANDING_LEFT);
            else if (input === 'PRESS down') this.player.setState(states.SITTING_LEFT);
            else if (input === 'PRESS up') this.player.setState(states.JUMPING_LEFT);
            else if (input === 'PRESS space') this.player.setState(states.ROLLING_LEFT);
        }
    }

    class RunningRight extends State {
        constructor(player){
            super('RUNNING RIGHT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 8;
            this.player.frameY = 6;
            this.player.speed = this.player.maxSpeed;
        }
        handleInput(input){
            if (input === 'PRESS left') this.player.setState(states.RUNNING_LEFT);
            else if (input === 'RELEASE right') this.player.setState(states.STANDING_RIGHT);
            else if (input === 'PRESS down') this.player.setState(states.SITTING_RIGHT);
            else if (input === 'PRESS up') this.player.setState(states.JUMPING_RIGHT);
            else if (input === 'PRESS space') this.player.setState(states.ROLLING_RIGHT);
        }
    }

    class JumpingLeft extends State {
        constructor(player){
            super('JUMPING LEFT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 3;
            if (this.player.onGround() || this.player.collideSwitchBottom) {
                if (this.player.collideSwitchBottom) this.player.collideSwitchBottom = false;
                this.player.vy -= this.player.jumpSpeed;
            }
            this.player.speed = -this.player.maxSpeed * 0.5;
        }
        handleInput(input){
            if (input === 'PRESS right') this.player.setState(states.JUMPING_RIGHT);
            else if (this.player.onGround()) this.player.setState(states.STANDING_LEFT);
            else if (this.player.vy > 0) this.player.setState(states.FALLING_LEFT);
        }
    }

    class JumpingRight extends State {
        constructor(player){
            super('JUMPING RIGHT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 2;
            if (this.player.onGround() || this.player.collideSwitchBottom) {
                if (this.player.collideSwitchBottom) this.player.collideSwitchBottom = false;
                this.player.vy -= this.player.jumpSpeed;
            }
            this.player.speed = this.player.maxSpeed * 0.5;
        }
        handleInput(input){
            if (input === 'PRESS left') this.player.setState(states.JUMPING_LEFT);
            else if (this.player.onGround()) this.player.setState(states.STANDING_LEFT);
            else if (this.player.vy > 0) this.player.setState(states.FALLING_RIGHT);
    
        }
    }

    class FallingLeft extends State {
        constructor(player){
            super('FALLING LEFT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 5;
            this.player.speed = -this.player.maxSpeed * 0.5;
        }
        handleInput(input){
            if (input === 'PRESS right') this.player.setState(states.FALLING_RIGHT);
            else if (this.player.onGround()) this.player.setState(states.STANDING_LEFT);
            else if (this.player.collideSwitchBottom) this.player.setState(states.STANDING_LEFT);
        }
    }

    class FallingRight extends State {
        constructor(player){
            super('FALLING RIGHT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 4;
            this.player.speed = this.player.maxSpeed * 0.5;
        }
        handleInput(input){
            if (input === 'PRESS left') this.player.setState(states.FALLING_LEFT);
            else if (this.player.onGround()) this.player.setState(states.STANDING_RIGHT);
            else if (this.player.collideSwitchBottom) this.player.setState(states.STANDING_RIGHT);
        }
    }

    class RollingLeft extends State {
        constructor(player){
            super('ROLLING LEFT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 11;
            this.player.speed = -this.player.maxSpeed;
        }
        handleInput(input){
            if (input === 'RELEASE space') this.player.setState(states.STANDING_LEFT);
            else if (input === 'PRESS left') this.player.setState(states.RUNNING_LEFT);
            else if (input === 'PRESS up') this.player.setState(states.JUMPING_LEFT);
            else if (input === 'PRESS right') this.player.setState(states.RUNNING_RIGHT);
            else if (input === 'PRESS down') this.player.setState(states.SITTING_LEFT);
        }
    }

    class RollingRight extends State {
        constructor(player){
            super('ROLLING RIGHT');
            this.player = player;
        }
        enter(){
            this.player.maxFrame = 6;
            this.player.frameY = 10;
            this.player.speed = this.player.maxSpeed;
        }
        handleInput(input){
            if (input === 'RELEASE space') this.player.setState(states.STANDING_RIGHT);
            else if (input === 'PRESS left') this.player.setState(states.RUNNING_LEFT);
            else if (input === 'PRESS up') this.player.setState(states.JUMPING_RIGHT);
            else if (input === 'PRESS right') this.player.setState(states.RUNNING_RIGHT);
            else if (input === 'PRESS down') this.player.setState(states.SITTING_RIGHT);
        }
    }

    class Static {
        constructor(x, y, width, height, player, image, sw, sh, duplicates) {
            this.player = player;
            this.x = x;
            this.offsetX = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.image = document.getElementById(image);
            this.sw = sw;
            this.sh = sh;
            this.duplicates = duplicates;
            this.buffer = 20; //a small fixed width to ensure side collision calculations on one object don't affect the next object
            this.legBoundaryLeft = this.player.x + (this.player.width*0.35);
            this.legBoundaryRight = this.player.x + (this.player.width*0.7);
            this.trigger = false; //generic trigger for special actions for instances of statics
        }
        draw(context){
            for (let i = 0; i < this.duplicates + 1; i++){
                context.drawImage(this.image, 0, 0, this.sw, this.sh, this.x + (i*this.width), this.y, this.width, this.height);
            }
            
        }
        beingCollidedWith(){
            this.legBoundaryLeft = this.player.x + (this.player.width*0.35) + this.player.offset;
            this.legBoundaryRight = this.player.x + (this.player.width*0.75) + this.player.offset;
    
            /////////////////////////////////////////  PLATFORMS  //////////////////////////////////////////////
            if (this.image == document.getElementById("boxImage")) {
                    //falling from left(state 8) or right (state 9) to land on top
                if (this.player.collideSwitchBottom == false && (this.player.currentState == this.player.states[8] || this.player.currentState == this.player.states[9] || this.player.currentState == this.player.states[10] || this.player.currentState == this.player.states[11]) && this.player.y + this.player.height + this.player.offsetY >= this.y  + this.player.offsetY && this.player.y + this.player.height  + this.player.offsetY <= (this.y + this.height*0.3)  + this.player.offsetY && this.legBoundaryRight > this.x && this.legBoundaryLeft < this.x + (this.width * (this.duplicates+1))) {
                    this.player.collideSwitchBottom = true;
                    this.player.y = this.y - this.player.height;
                }
    
                //making sure the player lands on top, not needed unless there's a bug later
    
                /* if (this.player.collideSwitchBottom && this.legBoundaryRight > this.x && this.legBoundaryLeft < this.x + this.width && this.player.y + this.player.height > this.y) {
                    this.player.y = this.y - this.player.height;
                } */
    
                //falling off the left
    
                if (this.player.collideSwitchBottom && this.legBoundaryRight <= this.x && this.legBoundaryRight >= this.x - this.buffer && this.player.y + this.player.height + this.player.offsetY >= this.y + this.player.offsetY && this.player.y + this.player.height + this.player.offsetY <= (this.y + this.height*0.3) + this.player.offsetY) {
                    this.player.collideSwitchBottom = false;
                } 
    
                //falling off the right
    
                if (this.player.collideSwitchBottom && this.legBoundaryLeft >= this.x + (this.width * (this.duplicates+1)) && this.legBoundaryLeft <= this.x + (this.width * (this.duplicates+1)) + this.buffer && this.player.y + this.player.height  + this.player.offsetY >= this.y  + this.player.offsetY && this.player.y + this.player.height  + this.player.offsetY <= (this.y + this.height*0.3) + this.player.offsetY) {
                    this.player.collideSwitchBottom = false;
                }
    
                //jumping off
    
                if (this.player.collideSwitchBottom && (this.player.currentState == this.player.states[6] || this.player.currentState == this.player.states[7])) {
                    this.player.collideSwitchBottom = false;  
                }
            }
    
            /////////////////////////////////////////  HAZARDS  //////////////////////////////////////////////
            if (this.image == document.getElementById("spikeImage")) {
                if ((this.player.currentState == this.player.states[8] || this.player.currentState == this.player.states[9] || this.player.currentState == this.player.states[10] || this.player.currentState == this.player.states[11]) && this.player.y + this.player.height >= this.y && this.player.y <= this.y + this.height && this.legBoundaryRight > this.x && this.legBoundaryLeft < this.x + (this.width * (this.duplicates+1))) {
                    this.player.alive = false;
                }
    
                    //player speed = 0 and playerX position is adjusted to account for any sprite overlap
    
                if (this.legBoundaryRight > this.x && this.legBoundaryLeft -25 < this.x + (this.width * (this.duplicates+1)) - 10 && this.player.y + this.player.height > this.y && this.player.y < this.y + this.height - (this.player.height*0.09)){
                    this.player.speed = 0;
                    //there's a slight deadspace at the top of the player sprite so underneath collision needs a slight fudge factor of 9%
    
                    /* if (this.player.x + this.player.offset < this.x + (this.width * (this.duplicates+1)) && this.player.x + this.player.offset > this.x + (this.width * (this.duplicates+1)) - (this.width/2)) {
                        //this.player.collideSwitchLeft = true;
                        this.player.speed = 0;
                    } 
                    else if (this.player.x + this.player.width + this.player.offset > this.x) {
                        //this.player.collideSwitchRight = true;
                        this.player.speed = 0;
                    } */
                }
            }
    
            if (this.image == document.getElementById("spikeInvertedImage")) {
                if (this.player.y <= this.y + this.height && !(this.player.y < this.y + (this.height/2)) && this.legBoundaryLeft < this.x + (this.width * (this.duplicates+1)) && this.legBoundaryRight > this.x) {
                    this.player.alive = false;
                }
                    //lok into adjusting for left/right facing to make box collision less obvious
    
                if (this.player.x + this.player.width + this.player.offset > this.x && this.player.x + this.player.offset < this.x + (this.width * (this.duplicates+1)) && this.player.y + this.player.height > this.y && this.player.y < this.y + this.height - (this.player.height*0.09)){
                    //console.log("collision");
                    //there's a slight deadspace at the top of the player sprite so underneath collision needs a slight fudge factor of 9%
    
                    if (this.player.x + this.player.offset < this.x + (this.width * (this.duplicates+1)) && this.player.x + this.player.offset > this.x + (this.width * (this.duplicates+1)) - (this.width/2)) {
                        //this.player.collideSwitchLeft = true;
                        this.player.speed = 0;
                    } 
                    else if (this.player.x + this.player.width + this.player.offset > this.x) {
                        //this.player.collideSwitchRight = true;
                        this.player.speed = 0;
                    }
                }
            }
        }
    }

    class Particle{
        constructor(player, color){
            this.x = player.x + (player.width/2) + player.offset;
            this.y = player.y + (player.width/2);
            this.size = Math.random() * (15 - 5) + 5;
            this.speedX = Math.random() * (3 - 1.5) + 1.5;
            this.speedY = Math.random() * (3 - -1.5) + -1.5;
            this.deadSpeedX = Math.random() * (5 - -5) + -5;
            this.deadSpeedY = Math.random() * (5 - -5) + -5;
    
            this.color = color; //'hsl(' + hue + ', 100%, 50%)';
        }
        update(player) {
            if (player.alive){
                this.x += this.speedX;
                this.y += this.speedY
            } else {
                this.x += this.deadSpeedX;
                this.y += this.deadSpeedY;
            }
            if (this.size > 0.2) this.size -= 0.2;
        }
        draw(ctx) {
            ctx.beginPath();
            ctx.fillStyle = this.color;
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();        
        }
    }

    class LoseScreen{
        constructor(gameWidth, gameHeight, size, player){
            this.x = gameWidth/2 + player.offset;
            this.y = gameHeight/2 + player.offsetY;
            this.size = size;
            this.num = Math.floor(Math.random() * 8)
            this.line1 = [
                'DOG',
                'That was...',
                'It\'s really not that hard',
                'Shame.',
                'I can\'t believe that he',
                'What?',
                'F5 to restart',
                'YOU DIED.',
                'Beware the man with'
            ];
            this.line2 = [
                'MURDERER!',
                'careless.',
                'for normal people ',
                'Shame.',
                'programmed me for THIS.',
                'Again??',
                'Alt+F4 to admit defeat',
                '',
                'the heavy \'@sweftbfgn\;'
            ];
        }
        draw(context, hue){
            context.beginPath();
            context.fillStyle = 'hsl(' + hue + ', 100%, 50%)';;
            context.textAlign = 'center';
            context.font = 'bolder ' + this.size + 'px Comic Sans'
            context.fillText (this.line1[this.num], this.x, this.y - (this.size*1.1));
            context.fillText (this.line2[this.num], this.x, this.y + (this.size*1.1));
            context.closePath();
        }
    }

    class Collectables {
        constructor(x, y, width, height, player, image, sw, sh, type, canvasHeight){
            this.x = x;
            this.y = y;
            this.yDown = this.y + 10;
            this.yUp = this.y - 10;
            this.ySwitch = false;
            this.width = width;
            this.height = height;
            this.player = player;
            this.type = type;
            this.canvasHeight = canvasHeight;
            this.destX = 3150;
            this.destY = this.canvasHeight - 419;
            //this.image = document.getElementById(image);
            this.sw = sw;
            this.sh = sh;
            this.frameX = 0;
            this.frameY = 0;
            this.maxFrame = 0;
            //animation timer
            this.fps = 30;
            this.frameTimer = 0;
            this.frameInterval = 1000/this.fps
            //
            this.playerLeft = this.player.x + this.player.offset;
            this.playerRight = this.player.x + this.player.width + this.player.offset;
            //
            this.collected = false;
            this.counted = false;
        }
        draw(context, deltaTime){
            if (this.frameTimer > this.frameInterval){
                if (this.frameX < this.maxFrame) this.frameX ++;
                else this.frameX = 0;
                this.frameTimer = 0;
            } else {
                this.frameTimer += deltaTime;
            }
            if (!this.collected){
                //context.drawImage(this.image, 0, 0, this.sw, this.sh, this.x, this.y, this.width, this.height);
                
                if (this.type == 'jump'){
                context.beginPath();
                context.fillStyle = 'rgba(0, 125, 250, 0.8';
                context.arc(this.x, this.y, this.width/2, 0, 2*Math.PI);
                context.fill();
                context.closePath();
                context.beginPath();
                context.fillStyle = 'rgba(0, 0, 250, 0.9';
                context.arc(this.x, this.y, this.width/4, 0, 2*Math.PI);
                context.fill();
                context.closePath();
                context.beginPath();
                context.font = "15px Impact";
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.fillText('JUMP', this.x, this.y-3);
                context.fillText('BOOST', this.x, this.y+12);
                if (this.y >= this.yUp && this.ySwitch == false) this.y += 0.5;
                if (this.y == this.yDown) this.ySwitch = true;
                if (this.y <= this.yDown && this.ySwitch == true) this.y -= 0.5;
                if (this.y == this.yUp) this.ySwitch = false;
                }
                else if (this.type == 'token'){
                    context.beginPath();
                    context.fillStyle = 'rgba(250, 125, 0, 0.8';
                    context.arc(this.x, this.y, this.width/2, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.fillStyle = 'rgba(250, 250, 0, 0.9';
                    context.arc(this.x, this.y, this.width/4, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.font = "15px Impact";
                    context.fillStyle = 'black';
                    context.textAlign = 'center';
                    context.fillText('TAKE', this.x, this.y-3);
                    context.fillText('ME ;o', this.x, this.y+12);
                    if (this.y >= this.yUp && this.ySwitch == false) this.y += 0.5;
                    if (this.y == this.yDown) this.ySwitch = true;
                    if (this.y <= this.yDown && this.ySwitch == true) this.y -= 0.5;
                    if (this.y == this.yUp) this.ySwitch = false;            
                }
                else if (this.type == 'speed'){
                    context.beginPath();
                    context.fillStyle = 'rgba(0, 250, 125, 0.8';
                    context.arc(this.x, this.y, this.width/2, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.fillStyle = 'rgba(0, 250, 250, 0.9';
                    context.arc(this.x, this.y, this.width/4, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.font = "15px Impact";
                    context.fillStyle = 'black';
                    context.textAlign = 'center';
                    context.fillText('SPEED', this.x, this.y-3);
                    context.fillText('BOOST', this.x, this.y+12);
    /*                 if (this.y >= this.yUp && this.ySwitch == false) this.y += 0.5;
                    if (this.y == this.yDown) this.ySwitch = true;
                    if (this.y <= this.yDown && this.ySwitch == true) this.y -= 0.5;
                    if (this.y == this.yUp) this.ySwitch = false; */
                }
                else if (this.type == 'gravity'){
                    context.beginPath();
                    context.fillStyle = 'rgba(125, 125, 125, 0.8';
                    context.arc(this.x, this.y, this.width/2, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.fillStyle = 'rgba(125, 125, 125, 0.9';
                    context.arc(this.x, this.y, this.width/4, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.font = "15px Impact";
                    context.fillStyle = 'black';
                    context.textAlign = 'center';
                    context.fillText('WEIGHT', this.x, this.y-3);
                    context.fillText('LOSS', this.x, this.y+12);
                }
                else if (this.type == 'end'){
                    context.beginPath();
                    context.fillStyle = 'rgba(50, 0, 50, 0.8';
                    context.arc(this.x, this.y, this.width/2, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.fillStyle = 'rgba(150, 0, 150, 0.9';
                    context.arc(this.x, this.y, this.width/4, 0, 2*Math.PI);
                    context.fill();
                    context.closePath();
                    context.beginPath();
                    context.font = "15px Impact";
                    context.fillStyle = 'black';
                    context.textAlign = 'center';
                    context.fillText('YOU', this.x, this.y-3);
                    context.fillText('WIN!', this.x, this.y+12);
                }
    
            }        
        }
        beingCollidedWith(){
            this.playerLeft = this.player.x + this.player.offset + (this.player.width * 0.1);
            this.playerRight = this.player.x + this.player.width + this.player.offset - (this.player.width*0.1);
    
            if (this.playerRight > this.x && this.playerLeft < this.x + this.width && this.player.y + this.player.height > this.y && this.player.y < this.y + this.height) {
                this.collected = true;
                if (this.type == 'jump') {
                    this.player.jumpBoostCollected = true;
                    this.player.jumpSpeed = 16;
                }
                if (this.type == 'token' && !this.counted) {
                    if (this.player.weight != 0.5) this.player.weight = 0.5;
                    this.player.tokensCollected += 1;
                    this.counted = true;
                    if (this.player.speedBoostCollected == true) {
                        this.player.speedBoostCollected = false;
                        if (this.player.speedBoostCap == 0){
                            this.player.speedBoostCap = this.player.speedBoostCounter;
                        }
                    }
                    if (!this.player.weight == 0.5) this.player.weight = 0.5;
                    // check to see if the counted variable needs to be here. erring on the side of caution
                }
                if (this.type == 'speed') {
                    this.player.speedBoostCollected = true;
                    this.player.speedBoostCounter += 1;
                }
                if (this.type == 'gravity'){
                    this.player.weight = 0.2;
                }
            }
        }
        moveAround(){
            //let num = Math.random() * (max - min) + min;
            if (this.type == 'speed' && this.player.tokensCollected < 1) {
                this.destX = 3150;
                this.destY = this.canvasHeight - 419;
            }
            else if (this.type == 'end' && this.player.tokensCollected < 1) {
                this.destX = 8725;
                this.destY = this.canvasHeight - 300;
            }
            
            if (this.destX == this.x && this.destY == this.y){
                if (this.type == 'speed'){
                    let max = this.canvasHeight - 169;
                    let min = this.canvasHeight - 669;
                    this.destX = Math.floor(Math.random() * (3400 - 2900) + 2900);
                    this.destY = Math.floor(Math.random() * (max - min) + min);
                }
                else if (this.type == 'end'){
                    let max = this.canvasHeight - 169;
                    let min = this.canvasHeight - 669;
                    this.destX = Math.floor(Math.random() * (8950 - 8500) + 8500);
                    this.destY = Math.floor(Math.random() * (max - min) + min);
                }
                
            }
    /*         let dx = this.destX - this.x;
            let dy = this.destY - this.y; */
            //let speed = 1;
           /*  if (this.x != x){
                this.x += dx/speed;
            }
            if (this.y != y){
                this.y += dy/speed;
            }
            if (this.x == x && this.y == y){
                this.destX = 0;
                this.destY = 0; */
    
            if (this.x < this.destX) this.x += 1;
            else if (this.x > this.destX) this.x -= 1;
            if (this.y < this.destY) this.y += 1;
            else if (this.y > this.destY) this.y -= 1;
            
        }
    
    }

    function handleParticles() {
        for (let i = 0; i < particlesArray3.length; i++) {
            particlesArray3[i].update();
            particlesArray3[i].draw();
            if (particlesArray3[i].size < 0.3) {
                particlesArray3.splice(i, 1);
                i--;
            }
        }
    }

    function drawStatusText(context, input, player){

    let hue = 0;
    hue = Math.random() * 360
    //debug text for states
    context.fillStyle = 'white';
    context.fillRect(player.offset + 12, player.offsetY + 20, 330, 40);
    context.font = 'bolder 28px Courier New';
    context.fillStyle = 'hsl(' + hue + ', 100%, 50%)';
    context.textAlign = 'left';
    //context.fillText('Last input: ' + input.lastKey, player.offset + 20, player.offsetY + 50);
    //context.fillText('Active state: ' + player.currentState.state, player.offset + 20, player.offsetY + 90);
    //context.fillText('Canvas Offset: ' + player.offset, player.offset + 20, player.offsetY + 130);
    context.fillText('Collected: ' + player.tokensCollected + ' / 10', player.offset + 20, player.offsetY + 50); //y + 270
    //context.fillText('Frame Counter: ' + player.frameCounter, player.offset + 20, player.offsetY + 100); //y + 270

        let score = (1000 - player.frameCounter) * player.tokensCollected;
        context.fillStyle = 'white';
        context.fillRect(player.offset + 12, player.offsetY + 70, 330, 40);
        context.fillStyle = 'hsl(' + hue + ', 100%, 50%)';
        context.fillText('Score: ' + score, player.offset + 20, player.offsetY + 100); //y + 270
    
    }

    function drawBackground (){
        const background = document.getElementById("background1");
        const tree1 = document.getElementById("foliage1");
        const tree2 = document.getElementById("foliage2");
        
        ctx.drawImage(background, 0, 0, 10000, 1000, -500, (canvas.height - 1000), 10000, 1000);
        ctx.drawImage(tree1, 0, 0, 674, 379, 4100, (canvas.height - 750), 674, 379);
        ctx.drawImage(tree2, 0, 0, 674, 379, 5700, (canvas.height - 680), 674, 379);
    
    }




    var hue = Math.random() * 360;
    const player = new Player(canvas.width, canvas.height);
    const input = new InputHandler();
    const loser = new LoseScreen(canvas.width, canvas.height, 50, player);


    var canvasOffset = player.offset;
    var canvasOffsetY = player.offsetY;

    const box1 = new Static(-200, canvas.height - 169, 250, 100, player, "boxImage", 300, 300, 0);
    const box2 = new Static(-100, canvas.height - 269, 250, 100, player, "boxImage", 300, 300, 0);
    const box3 = new Static(375, (canvas.height - 500), 250, 100, player, "boxImage", 300, 300, 0);
    const box4 = new Static(-125, canvas.height - 599, 800, 50, player, "boxImage", 300, 300, 0);
    const box5 = new Static(980, canvas.height - 669, 900, 50, player, "boxImage", 300, 300, 0);
    const box6 = new Static(1550, canvas.height - 269, 300, 100, player, "boxImage", 300, 300, 0);
    const box7 = new Static(5300, canvas.height - 269, 100, 100, player, "boxImage", 300, 300, 0);
    const box8 = new Static(5400, canvas.height - 469, 100, 100, player, "boxImage", 300, 300, 0);
    const box9 = new Static(5300, canvas.height - 609, 100, 100, player, "boxImage", 300, 300, 0);
    const box10 = new Static(4000, canvas.height - 769, 1000, 100, player, "boxImage", 300, 300, 0);
    const box11 = new Static(3400, canvas.height - 429, 450, 100, player, "boxImage", 300, 300, 0);
    const box12 = new Static(3200, canvas.height - 70, 100, 50, player, "boxImage", 300, 300, 0);
    const box13 = new Static(5500, canvas.height - 769, 100, 100, player, "boxImage", 300, 300, 0);
    const box14 = new Static(6000, canvas.height - 869, 1000, 100, player, "boxImage", 300, 300, 0);
    const box15 = new Static(7700, canvas.height - 275, 100, 100, player, "boxImage", 300, 300, 0);
    const box16 = new Static(7950, canvas.height - 530, 100, 100, player, "boxImage", 300, 300, 0);
    const box17 = new Static(8200, canvas.height - 125, 100, 50, player, "boxImage", 300, 300, 0);



    const collect1 = new Collectables(-200, canvas.height - 150, 100, 100, player, null, 0, 0, 'jump', canvas.height);
    const collect2 = new Collectables(-0, canvas.height - 894, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect3 = new Collectables(1600, canvas.height - 69, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect4 = new Collectables(1500, canvas.height - 719, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect5 = new Collectables(2450, canvas.height - 369, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect6 = new Collectables(3150, canvas.height - 419, 100, 100, player, null, 0, 0, 'speed', canvas.height);
    const collect7 = new Collectables(4250, canvas.height - 560, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect8 = new Collectables(4800, canvas.height - 350, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect9 = new Collectables(3625, canvas.height - 500, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect10 = new Collectables(5750, canvas.height - 840, 100, 100, player, null, 0, 0, 'gravity', canvas.height);
    const collect11 = new Collectables(7100, canvas.height - 350, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect12 = new Collectables(7850, canvas.height - 550, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect13 = new Collectables(8500, canvas.height - 500, 100, 100, player, null, 0, 0, 'token', canvas.height);
    const collect14 = new Collectables(8725, canvas.height - 300, 100, 100, player, null, 0, 0, 'end', canvas.height);


    const spike1 = new Static(1100, (canvas.height - 75), 50, 75, player, "spikeImage", 50, 75, 0);
    const spike2 = new Static(1350, (canvas.height - 75), 50, 75, player, "spikeImage", 50, 75, 2);
    const spike3 = new Static(2000, (canvas.height - 75), 50, 75, player, "spikeImage", 50, 75, 2);
    const spike4 = new Static(4350, (canvas.height - 75), 50, 75, player, "spikeImage", 50, 75, 2);
    const spike5 = new Static(3700, (canvas.height - 459), 50, 75, player, "spikeImage", 50, 75, 2);
    const spike6 = new Static(3400, (canvas.height - 459), 50, 75, player, "spikeImage", 50, 75, 2);
    const spike7 = new Static(3700, (canvas.height - 384), 50, 75, player, "spikeInvertedImage", 50, 75, 2);
    const spike8 = new Static(3400, (canvas.height - 384), 50, 75, player, "spikeInvertedImage", 50, 75, 2);
    const spike9 = new Static(5900, (canvas.height - 75), 50, 75, player, "spikeImage", 50, 75, 5);
    const spike10 = new Static(6000, (canvas.height - 899), 50, 75, player, "spikeImage", 50, 75, 15);
    const spike11 = new Static(6800, (canvas.height - 899), 50, 75, player, "spikeImage", 50, 75, 3);
    const spike12 = new Static(6150, (canvas.height - 819), 50, 75, player, "spikeInvertedImage", 50, 75, 12);
    const spike13 = new Static(6800, (canvas.height - 75), 50, 75, player, "spikeImage", 50, 75, 5);
    const spike14 = new Static(7700, (canvas.height - 245), 50, 75, player, "spikeInvertedImage", 50, 75, 1);
    const spike15 = new Static(7950, (canvas.height - 500), 50, 75, player, "spikeInvertedImage", 50, 75, 1);

    const states = {
        STANDING_LEFT: 0,
        STANDING_RIGHT: 1,
        SITTING_LEFT: 2,
        SITTING_RIGHT: 3,
        RUNNING_LEFT: 4,
        RUNNING_RIGHT: 5,
        JUMPING_LEFT: 6,
        JUMPING_RIGHT: 7,
        FALLING_LEFT: 8,
        FALLING_RIGHT: 9,
        ROLLING_LEFT: 10,
        ROLLING_RIGHT: 11
    }

    let lastTime = 0;
    function animate (timeStamp){
        const deltaTime = timeStamp - lastTime;
        lastTime = timeStamp;
        ctx.save();
        ctx.translate(-canvasOffset, -canvasOffsetY);
        ctx.clearRect(canvasOffset, 0, canvas.width, canvas.height);
        drawBackground();
        
        player.update(input.lastKey);
        canvasOffset = player.offset;
        canvasOffsetY = player.offsetY;

        if (player.currentState == player.states[10] || player.currentState == player.states[11]) {
            particlesArray.push(new Particle(player, 'blue'));
        }
        if (!player.alive){
            particlesArray.push(new Particle(player, 'red'));
            particlesArray2.push(new Particle(player, 'red'));

        }
        if (player.maxSpeed == 15){
            particlesArray.push(new Particle(player, 'gold'));
        }
        
        if (particlesArray.length>0){
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update(player);
                particlesArray[i].draw(ctx);
                if (particlesArray[i].size < 0.3) {
                    particlesArray.splice(i, 1);
                    i--;
                }
            }
        }
            
    

        box1.beingCollidedWith();
        box2.beingCollidedWith();
        box3.beingCollidedWith();
        box4.beingCollidedWith();
        box5.beingCollidedWith();
        box6.beingCollidedWith();
        box7.beingCollidedWith();
        box8.beingCollidedWith();
        box9.beingCollidedWith();
        box10.beingCollidedWith();
        box11.beingCollidedWith();
        box12.beingCollidedWith();
        box13.beingCollidedWith();
        //box14.beingCollidedWith(); not necessary
        box15.beingCollidedWith();
        box16.beingCollidedWith();
        box17.beingCollidedWith();

        spike1.beingCollidedWith();
        spike2.beingCollidedWith();
        spike3.beingCollidedWith();
        if (player.x + player.offset > 5000) spike4.trigger = true;
        if (!spike4.trigger) spike4.beingCollidedWith();        
        spike5.beingCollidedWith();        
        spike6.beingCollidedWith();
        spike7.beingCollidedWith();
        spike8.beingCollidedWith();
        spike9.beingCollidedWith();
        spike10.beingCollidedWith();
        //spike11.beingCollidedWith(); do not reactivate
        spike12.beingCollidedWith();
        spike13.beingCollidedWith();
        spike14.beingCollidedWith();
        spike15.beingCollidedWith();



        collect1.beingCollidedWith();
        collect2.beingCollidedWith();
        collect3.beingCollidedWith();
        collect4.beingCollidedWith();
        collect5.beingCollidedWith();
        collect6.beingCollidedWith();
        collect6.moveAround();
        collect7.beingCollidedWith();
        collect8.beingCollidedWith();
        collect9.beingCollidedWith();
        collect10.beingCollidedWith();
        collect11.beingCollidedWith();
        collect12.beingCollidedWith();
        collect13.beingCollidedWith();
        collect14.beingCollidedWith();
        collect14.moveAround();
        player.collision();

        collect1.draw(ctx);
        box1.draw(ctx);

        box2.draw(ctx);
        box3.draw(ctx);
        box4.draw(ctx);
        box5.draw(ctx);
        box6.draw(ctx);
        box7.draw(ctx);
        box8.draw(ctx);
        box9.draw(ctx);
        box10.draw(ctx);
        box11.draw(ctx);
        box12.draw(ctx);
        box13.draw(ctx);
        box14.draw(ctx);
        box15.draw(ctx);
        box16.draw(ctx);
        box17.draw(ctx);

        spike1.draw(ctx);
        spike2.draw(ctx);
        spike3.draw(ctx);
        if (!spike4.trigger) spike4.draw(ctx);
        spike5.draw(ctx);
        spike6.draw(ctx);
        spike7.draw(ctx);
        spike8.draw(ctx);
        spike9.draw(ctx);
        spike10.draw(ctx);
        spike11.draw(ctx);
        spike12.draw(ctx);
        spike13.draw(ctx);
        spike14.draw(ctx);
        spike15.draw(ctx);

        
        collect2.draw(ctx);
        collect3.draw(ctx);
        collect4.draw(ctx);
        collect5.draw(ctx);
        collect6.draw(ctx);
        collect7.draw(ctx);
        collect8.draw(ctx);
        collect9.draw(ctx);
        collect10.draw(ctx);
        collect11.draw(ctx);
        collect12.draw(ctx);
        collect13.draw(ctx);
        collect14.draw(ctx);

        player.draw(ctx, deltaTime);

        if (particlesArray2.length>0){
            for (let i = 0; i < particlesArray2.length; i++) {
                particlesArray2[i].update(player);
                particlesArray2[i].draw(ctx);
                if (particlesArray2[i].size < 0.3) {
                    particlesArray2.splice(i, 1);
                    i--;
                }
            }
        }

        ctx.drawImage(caveEntrance, 0, 0, 313, 1000, 7110, 0, 313, 1000);

        drawStatusText(ctx, input, player);

        //console.log(player.frameCounter);

        //console.log(Math.random() * (3 - -1.5) + -1.5);
       /*  console.log('PlayerY: ' + player.y);
        console.log('Box2: ' + box2.y); */
        //console.log(player.speedBoostCap);
        //console.log('math: ' + (player.y + player.height + player.offsetYPadding));

        ctx.restore();

        if (collect14.collected) {
            player.countFrames = false;
            player.score = (1000 - player.frameCounter) * player.tokensCollected;
            ctx.beginPath();
            ctx.font = '500px Helvetica';
            ctx.fillStyle = 'purple';
            ctx.textAlign = 'center';
            ctx.fillText('WIN', canvas.width/2 ,canvas.height/2 - 100);
            ctx.closePath();
            ctx.beginPath();
            ctx.font = '300px Helvetica'
            ctx.closePath();
            if (player.score > 4000) {
                ctx.fillText('GRADE: A', canvas.width/2 ,canvas.height/2 + 250);
            } else if (player.score > 3000 && player.score <= 4000) {
                ctx.fillText('GRADE: B', canvas.width/2 ,canvas.height/2 + 250);
            } else if (player.score > 2000 && player.score <= 3000) {
                ctx.fillText('GRADE: C', canvas.width/2 ,canvas.height/2 + 250);
            } else if (player.score > 1000 && player.score <= 2000) {
                ctx.fillText('GRADE: D', canvas.width/2 ,canvas.height/2 + 250);
            } else if (player.score <= 1000) {
                ctx.fillText('GRADE: F', canvas.width/2 ,canvas.height/2 + 250);
            }

        }   

        if (!player.alive){
            loser.draw(ctx, hue);
            hue += 5;
            if (loser.size <= 120) loser.size +=1;
            //else if (loser.size > 120) loser.size = 120;
            
        }
        requestAnimationFrame(animate);
    };
    animate(0);
});


//50px by 50px tile texture to for loop across platforms

//enemy


//good runs 3390 3840 3460
//med runs 3132 
//bad runs 560 970
//incomplete runs 4128 3934

//epiz_30823615!
//C_$4
//http://stevesduggame.epizy.com/